# OBDscribe – v0 Build Goals & Expectations

Version: 0.1  
Scope: First working version of OBDscribe (“v0”) – enough to demo and test with real shops, without full Phase 2–4 complexity.

---

## 1. High-Level Outcome

By the end of v0, we want to have:

- A **working cloud web app** that a service writer can open in a browser, log into, and use to:
  - Enter **vehicle info + OBD codes + complaint**.
  - Click **Generate Report**.
  - Receive a **usable, editable tech summary and customer explanation** generated by AI.
- A system that is:
  - **Stable enough** for small real-world pilots.
  - **Structured enough** that we can layer on risk, estimates, and integrations later without rewrites.

v0 is about **“prove this is useful in the real world”**, not about covering all future features.

---

## 2. Product Goals (What the User Can Do)

By the end of v0, a service writer should be able to:

1. **Log into OBDscribe**
   - Visit the web app.
   - Enter email + password.
   - Land on the **New Report** screen after successful login.

2. **Create a new report**
   - Fill in:
     - Year, make, model (and optional trim).
     - Mileage.
     - One or more OBD codes.
     - Customer complaint.
     - Optional advisor/tech notes.
   - Click **Generate Report** and see a clear loading state.

3. **View AI-generated output**
   - See two main sections:
     - **Tech View** – more detailed summary for internal use.
     - **Customer View** – simplified explanation they could copy into texts/emails or talk through.
   - See **maintenance suggestions** appropriate to mileage band (even if generic).
   - Edit the generated text before using it.

4. **Access basic history (v0.1 if not in first sprint)**
   - View a simple table of past reports for their shop.
   - Click into a past report and see its input + output.

5. **Adjust basic settings (v0.1 if not in first sprint)**
   - Shop name.
   - Labor rate (for future estimates, even if unused in v0).

The core v0 demo flow:  
**Login → New Report → Generate → Tech & Customer explanation → (optionally) check history.**

---

## 3. UX & UI Expectations

- Desktop-first layout:
  - Clean, “app-like” layout with a left or top nav (no clutter).
  - Simple routes:
    - `/login`
    - `/app/new-report`
    - `/app/history` (later)
    - `/app/settings` (later)
- The **New Report** page is the heart of the app:
  - Inputs on one side (or top), output on the other (or below).
  - Clear labels and validation:
    - Codes field should nudge user toward formats like `P0301, P0171`.
- Output is editable:
  - Tech View and Customer View are text areas or simple rich text fields that can be refined.
- Error states:
  - Friendly messages when AI errors occur (e.g., “We couldn’t generate a report this time. Please try again.”).
  - No raw stack traces or confusing technical errors exposed to users.

---

## 4. Technical Scope for v0 (What Must Exist)

### 4.1 Frontend

- Next.js app (TypeScript + Tailwind) with:
  - Layout and navigation.
  - `/login` page.
  - `/app/new-report` page with:
    - Input form for vehicle, codes, complaint, notes.
    - Display of AI outputs.
  - Optional `/app/history` and `/app/settings` routes (can be stubbed if needed for later).

### 4.2 Backend / API

- API routes:
  - `/api/generate-report`
    - Validates input.
    - Enriches with local DTC meanings + mileage band.
    - Calls `aiEngine.generateReport()`.
    - Stores report in Postgres.
    - Returns structured JSON to frontend.
  - `/api/auth/login`
    - Verifies email/password.
    - Returns a session token / cookie (minimum viable auth).
  - `/api/health`
    - Returns a simple `{ status: "ok", version: "v0.x.x" }`.

- Optional for v0.1 (not blocking v0 demo):
  - `/api/reports` for history table.
  - `/api/settings` for shop settings.

### 4.3 Data & Multi-Tenant

- Postgres schema with at least:
  - `shops`:
    - `id`, `name`, basic fields.
  - `users`:
    - `id`, `email`, `password_hash`, `shop_id`, `role`.
  - `reports`:
    - `id`, `shop_id`, `user_id`.
    - Input fields (vehicle, codes, complaint, notes).
    - Output fields (techView, customerView, maintenanceSuggestions).
    - `prompt_version`, `mode`.
  - `dtc_codes`:
    - Basic DTC code → generic meaning mappings.
  - `maintenance_bands`:
    - Simple rules for mileage → generic suggestions.

---

## 5. AI Behavior Expectations

By end of v0:

1. **Model usage**
   - Use OpenAI advanced reasoning model (e.g., `gpt-5.1-thinking`).
   - No external tools in v0:
     - No `web_search` browsing.
     - No `vin_decode`.
     - No `job_lookup`.

2. **Input to AI**
   - Structured JSON based on `GenerateReportInput`:
     - Vehicle info.
     - Codes and their meanings (from local table).
     - Complaint and notes.
     - Mileage band.

3. **Output from AI**
   - AI returns valid JSON matching `GenerateReportOutput`:
     - `techView`
     - `customerView`
     - `maintenanceSuggestions`
     - (Placeholders for future fields like `riskAssessment`, `estimateRange` can exist but may be empty.)

4. **JSON reliability**
   - Use JSON-only responses from the model.
   - Implement basic JSON validation and:
     - Optionally, one retry if parsing fails.
     - Otherwise, return a user-friendly error.

5. **Prompt versioning and mode**
   - Include `prompt_version` in AI prompt and store it in each `Report`.
   - Accept and pass through a `mode` field (`production`, `sandbox`, `debug`), even if all behavior is the same for v0.

---

## 6. Stability, Safety, and Ops Expectations

By end of v0, the system should have:

1. **Basic rate limiting**
   - Simple rate limit around `/api/generate-report`:
     - Protect against accidental spam and runaway loops.
     - Reasonable default, e.g., N requests per minute per user or IP.

2. **Error handling**
   - Catch and classify:
     - AI errors (timeout, quota, 5xx).
     - DB errors.
     - Unexpected internal errors.
   - Always return a clean, non-technical message to the frontend while logging the details server-side.

3. **Health check**
   - `/api/health` is implemented and returns:
     - Status.
     - Version.
   - Ready to be used by uptime monitors and for quick smoke checks.

4. **Logging**
   - Log:
     - Requests to `/api/generate-report` (sanitized).
     - AI model errors.
     - Rate limit events.
   - Logs stored in a way that can be inspected during early testing.

---

## 7. Non-Goals for v0 (Explicitly Out of Scope)

To avoid scope creep, these are **not required** for v0:

- Risk assessment fields (`safety`, `drivability`, `longTermDamage`).
- Any form of price / estimate generation.
- VIN decoding and deep vehicle metadata.
- Labor time and parts catalog integrations.
- Full user management UI (invite users, roles management).
- Mobile app or desktop wrapper (Electron/Tauri).
- Fancy dashboards or analytics.

These features belong to **Phases 2–4**, not the v0 milestone.

---

## 8. “Demo-Ready” Checklist

We can consider v0 *“build complete”* when all of the following are true:

- [ ] A user can log in successfully.
- [ ] The **New Report** page loads and is usable.
- [ ] Submitting a valid form calls `/api/generate-report` and:
  - [ ] Writes a report row in Postgres.
  - [ ] Returns a structured response to the frontend.
- [ ] Tech View and Customer View are populated with AI-generated content and editable.
- [ ] Invalid inputs are handled with friendly error messages (frontend).
- [ ] JSON failures or AI errors are handled with a clear message (no blank screen).
- [ ] `/api/health` returns `status: "ok"`.
- [ ] Basic rate limiting on `/api/generate-report` is active.
- [ ] At least one seeded `shop` and `user` is wired into login and data flow.
- [ ] The system can be used end-to-end for a small set of real-world test cases without crashing.

Once all of the above boxes are ticked, you have a **real v0**: something you can show to an advisor, founder friend, or shop owner and say,  
“This is OBDscribe — the service writer copilot we’re building.”